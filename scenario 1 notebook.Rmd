---
title: "Estimating present population based on Mobile Network Operator data - a simulation study"
author: "Giulia and Marco"
output:
  html_document:
    df_print: paged
---

```{r message=FALSE}
library(tidyverse)
library(data.table)
library(sf)
library(lubridate)
library(raster)
library(Matrix)

set.seed(762)
```



# Loading in / cleaning census data from  Germany
For this version census data from Germany was retrieved. This data entails population count categories on the 1km*1km tile level. Additional meta information such as age proportions etc. are included and will be utilized in subsequent versions. Furthermore, for computational reasons, this version will only focus on a subset of the tiles located in the state of Bavaria. However, the code is written in a modularized way in order to easily scale, once a high computing machine is available.     
In the following chunk this census data is cleaned and random (realistic) values for the population count variable are generated instead of the categorical scale. These random values are based on the relevant category the respective tile entails. Furthermore, this population value is used throughout this version as the number of mobile phones in a specific tile. This means, this variable represents the u vector in the working paper. In subsequent versions this original population value will be adjusted based on auxiliary variables to get a more realistic count of people with mobile phones in the tile area.
```{r}
census.raw <- read_csv2("Data/Census data Germany/Zensus 1km.csv")
census.de.1km <- census.raw %>% 
  dplyr::select(x = x_mp_1km, y = y_mp_1km, tile.id = Gitter_ID_1km, pop = Einwohner) %>% 
  mutate(internal.id = row_number()) %>% 
  mutate(pop.category = pop) %>% 
  mutate(pop = case_when(pop == 1 ~ sample(1:250, n(), replace = T), # rural
                         pop == 2 ~ sample(251:500, n(), replace = T), # rural
                         pop == 3 ~ sample(501:2000, n(), replace = T), # rural
                         pop == 4 ~ sample(2001:4000, n(), replace = T), # sub urban
                         pop == 5 ~ sample(4001:8000, n(), replace = T), # sub urban
                         pop == 6 ~ sample(8001:12000, n(), replace = T), # urban
                         pop == "-1" ~ as.integer(1))) # undisclosed, rural


# Filtering only tiles within specified bounding box, creating tile polygons and transforming the object to an sf object with a specific coordinate reference system (projection)
census.de.1km.tile <- census.de.1km %>% 
  filter(between(y, 2800000, 2850000), # 285
         between(x, 4500000, 4600000)) %>%
    # filter(between(y, 2650000, 3000000), # 285
    #      between(x, 4300000, 4600000)) %>%
  rasterFromXYZ(crs = st_crs(3035)$proj4string) %>% 
  rasterToPolygons() %>%
  st_as_sf() %>% 
  st_transform(crs = 3035) %>% 
  mutate(pop.category = case_when(pop %in% c("-1", 1, 2, 3, 4) ~ "rural",
                                  pop %in% c(5) ~ "suburban",
                                  pop %in% c(6) ~ "urban"))


# Bounding box of focus area
# focus.bb <- data.frame(maxlat = 4600000, minlat = 4300000,
#                        maxlong = 3000000, minlong = 2650000)
focus.bb <- data.frame(maxlat = 4600000, minlat = 4300000,
                       maxlong = 2850000, minlong = 2650000)


# Focusing on the area within the bounding box (south bavaria)
census.de.1km %>% 
  sample_n(10000) %>% 
  ggplot() +
  geom_point(aes(x = x, y = y)) +
  geom_rect(data = focus.bb, aes(ymin = minlong, ymax = maxlong, 
                                 xmin = minlat, xmax = maxlat), 
            color = "red", fill = "transparent") +
  ggtitle("Focusing on the area within the bounding box (South Bavaria)")
  

# Focus area
census.de.1km.tile %>% 
  ggplot() +
  geom_sf(aes(fill = pop)) +
  ggtitle("South Bavaria 1km*1km tiles")

# Histograms of population distribution
census.de.1km.tile %>% 
  ggplot() +
  geom_histogram(aes(pop)) +
  ggtitle("Number of mobile phone distribution per tile")

```

# Generation of the Radio Network
```{r}
bb.antenna <- c(xmin = 4500000, xmax = 4600000,
                ymin = 2800000, ymax = 2850000)

layer.1 <- st_make_grid(census.de.1km.tile, cellsize = 10000, square = F) # different cell size (qm)
antenna.1 <- layer.1 %>% 
  st_coordinates() %>% 
  as_tibble() %>% 
  dplyr::select(X, Y) %>%
  distinct() %>%  # remove duplicate corners 
  mutate(tower.ID = paste0("RT", 1:n())) %>% 
  slice(rep(1:n(), each = 3)) %>% 
  group_by(tower.ID) %>% 
  mutate(antenna.ID = paste("A", tower.ID, 1:3, sep = ".")) %>% 
  ungroup() %>% 
  mutate(antenna.kind = str_sub(antenna.ID, -1)) %>% 
  mutate(X = case_when(str_sub(antenna.ID, -1) == "1" ~ X - 0,
                       str_sub(antenna.ID, -1) == "2" ~ X + 2211,
                       str_sub(antenna.ID, -1) == "3" ~ X - 2211)) %>%
  mutate(Y = case_when(str_sub(antenna.ID, -1) == "1" ~ Y - 3000, # meter distance apart
                       str_sub(antenna.ID, -1) == "2" ~ Y + 2211,
                       str_sub(antenna.ID, -1) == "3" ~ Y + 2211)) %>%
  st_as_sf(coords = c("X", "Y")) %>% 
  st_buffer(4000) %>% # 4000 m radius coverage are per antenna
  st_sf(., crs = 3035) %>% 
  st_crop(bb.antenna) %>% 
  st_set_agr("aggregate") %>% # clean up
  mutate(cell.centroid = st_centroid(geometry))

rotation = function(a){
  r = a * pi / 180 #degrees to radians
  matrix(c(cos(r), sin(r), -sin(r), cos(r)), nrow = 2, ncol = 2)
} 

layer.2.geo <- census.de.1km.tile %>% 
  filter(pop.category %in% c("suburban", "urban")) %>% 
  st_make_grid(cellsize = 2000, square = T) %>% 
  st_geometry()
layer.2.cntrd <- st_centroid(layer.2.geo)
layer.2 <- (layer.2.geo - layer.2.cntrd) * rotation(35) + layer.2.cntrd # rotate by 35 degrees


antenna.2 <- layer.2 %>% 
  st_coordinates() %>% 
  as_tibble() %>% 
  dplyr::select(X, Y) %>%
  distinct() %>%  # remove duplicate corners 
  mutate(tower.ID = paste0("ST", 1:n())) %>% 
  slice(rep(1:n(), each = 3)) %>% 
  group_by(tower.ID) %>% 
  mutate(antenna.ID = paste("A", tower.ID, 1:3, sep = ".")) %>% 
  ungroup() %>% 
  mutate(antenna.kind = str_sub(antenna.ID, -1)) %>% 
  mutate(X = case_when(str_sub(antenna.ID, -1) == "1" ~ X - 0,
                       str_sub(antenna.ID, -1) == "2" ~ X + 1060,
                       str_sub(antenna.ID, -1) == "3" ~ X - 1060)) %>%
  mutate(Y = case_when(str_sub(antenna.ID, -1) == "1" ~ Y - 1500, # meter distance apart
                       str_sub(antenna.ID, -1) == "2" ~ Y + 1060,
                       str_sub(antenna.ID, -1) == "3" ~ Y + 1060)) %>%
  st_as_sf(coords = c("X", "Y")) %>% 
  st_buffer(2000) %>% # 6000 m radius coverage are per antenna
  st_sf(., crs = 3035) %>% 
  st_crop(bb.antenna) %>% 
  st_set_agr("aggregate") %>%  # clean up
  mutate(cell.centroid = st_centroid(geometry))

layer.3.geo <- census.de.1km.tile %>% 
  filter(pop.category %in% c("urban")) %>% 
  st_make_grid(cellsize = 1000, square = T) %>% 
  st_geometry()
layer.3.cntrd <- st_centroid(layer.3.geo)
layer.3 <- (layer.3.geo - layer.3.cntrd) * rotation(35) + layer.3.cntrd # rotate by 35 degrees

antenna.3 <- layer.3 %>% 
  st_coordinates() %>% 
  as_tibble() %>% 
  dplyr::select(X, Y) %>%
  distinct() %>%  # remove duplicate corners 
  mutate(tower.ID = paste0("UT", 1:n())) %>% 
  slice(rep(1:n(), each = 3)) %>% 
  group_by(tower.ID) %>% 
  mutate(antenna.ID = paste("A", tower.ID, 1:3, sep = ".")) %>% 
  ungroup() %>% 
  mutate(antenna.kind = str_sub(antenna.ID, -1)) %>% 
  mutate(X = case_when(str_sub(antenna.ID, -1) == "1" ~ X - 0,
                       str_sub(antenna.ID, -1) == "2" ~ X + 353,
                       str_sub(antenna.ID, -1) == "3" ~ X - 353)) %>%
  mutate(Y = case_when(str_sub(antenna.ID, -1) == "1" ~ Y - 500, # meter distance apart
                       str_sub(antenna.ID, -1) == "2" ~ Y + 353,
                       str_sub(antenna.ID, -1) == "3" ~ Y + 353)) %>%
  st_as_sf(coords = c("X", "Y")) %>% 
  st_buffer(500) %>% # 6000 m radius coverage are per antenna
  st_sf(., crs = 3035) %>% 
  st_crop(bb.antenna) %>% 
  st_set_agr("aggregate") %>% # clean up
  mutate(cell.centroid = st_centroid(geometry))

coverage.areas <- bind_rows(antenna.1, antenna.2, antenna.3)


exp.layer.1 <- antenna.1 %>% 
  filter(tower.ID %in% c("RT120")) 
exp.layer.2 <- antenna.2 %>% 
  filter(tower.ID %in% c("ST331")) 
exp.layer.3 <- antenna.3 %>% 
  filter(tower.ID %in% c("UT132")) 

  
ggplot() +
  geom_sf(data = exp.layer.1, aes(col = antenna.kind), fill = NA) +
  geom_sf(data = exp.layer.2, aes(col = antenna.kind), fill = NA) +
  geom_sf(data = exp.layer.3, aes(col = antenna.kind), fill = NA) +
  ggtitle("Example coverage area per tower per layer", subtitle = "Each color represents a different antenna on the same tower")

ggplot() +
  geom_sf(data = antenna.1, aes(col = antenna.kind), fill = NA) +
  geom_sf(data = antenna.2, aes(col = antenna.kind), fill = NA) +
  geom_sf(data = antenna.3, aes(col = antenna.kind), fill = NA) +
  ggtitle("Complete coverage", subtitle = "Urban areas have more coverage through 3 layers")

```


# Device-to-cell association 
In this module tiles (also mobile devices) and coverage areas are connected. We are interested which tiles (meaning which cell phones in a generic tile) can receive a signal from which radio cell(s). One could also ask, which radio cell "illuminates" which tile(s). Furthermore, to make this scenario more realistic, we will zoom in to the level of mobile devices, meaning disaggregating the `pop` variable by approximation. This is particularly important when multiple radio cells illuminate a generic tile. Given the possibly different signal strengths of the respective radio cells for this tile, a probability can be calculated for the mobile devices within the tile, which describes the probability of a mobile device being logged in to a specific radio cell. This probability depends on the radio specific signal strength for this tile which currently is a function dependening on the distance between the tile centroid of the mobile device and the centroid of the radio cell. (Insert formula).    

`dev.to.cell` calculates the tile specific signal strength to every relevant radio cell and the probabilities p (`weight.pij`), defined in the working paper. `P.mat` represents the matrix P, defined in the working paper, as a sparse matrix. The rows are the tiles, the columns are the radio cells and the matrix is populated with the probabilities `weight.pij`. `U.vec` represents the population column vector. `C.vec` entails the stochastic process which cell phone of a specific tile estimated to be logged in to which radio cell. This info again can be aggreagted to population counts within a radio cell. The estimated population total cannot exceed the true population total because it is insured that no cell phone is logged into multiple radio cells at the same time.
```{r}
dev.to.cell <- census.de.1km.tile %>% 
  mutate(tile.centroid = st_centroid(geometry)) %>%
  st_join(coverage.areas, left = F) %>% 
  mutate(dist.sij = st_distance(cell.centroid, tile.centroid, by_element = T)) %>% 
  mutate(signal.sij = 1 / (dist.sij * random.vec)) %>% # dependent threshold value
  # mutate(signal.sij = (2^(-1/as.numeric(dist.sij)))) %>% # dependent threshold value
  group_by(internal.id) %>%
  mutate(weight.pij = as.numeric(signal.sij / sum(signal.sij, na.rm = T))) 

# sparse matrix of device to cell
P.mat <- dev.to.cell %>% 
  dplyr::select(internal.id, universal.id, weight.pij) %>% 
  st_drop_geometry() %>% 
  pivot_wider(id_cols = universal.id, names_from = internal.id, 
              values_from = weight.pij) %>% 
  as.matrix() %>% 
  Matrix(sparse = T)

# u-vector
U.vec <- census.de.1km.tile %>% 
  dplyr::select(internal.id, pop)

# C-vector (total count of mobile phones of a tile stochastically assigned to a radio cell based on P --> here: weight.pij)
C.vec <- dev.to.cell %>% 
  dplyr::select(internal.id, universal.id, pop, weight.pij) %>% 
  st_drop_geometry() %>%
  split(.$internal.id) %>% 
  map(~sample(x = .$universal.id, mean(.$pop),
              replace = T, prob = .$weight.pij)) %>% 
  map(as_tibble, .id = "internal.id") %>% 
  map(~group_by(., value)) %>% 
  map(~summarise(., pop.count.rand = n(), .groups = "drop"))
# TO DO: Implement example of the stochastic process
```

## Current questions:
* **What is the difference between the module "Generation of radio network" and the module "Network modelling" in the working paper**    
* **What is the definition of a seed in terms of an antenna (module Network modelling)**    

## Major TO DOs:



